import Boom from '@hapi/boom';
import MimeTypes from 'mime-types';

import { HttpStatus, AuthScope } from '@/lib/Constants';
import storageStrategy from '@/lib/io/storage/StorageStrategy';
import Joi from '@/lib/model/Joi';

import MvcrAccessEventsDAO from '@/lib/db/MvcrAccessEventsDAO';

/**
 * Provides read-only access to MOVE file storage.
 *
 * See {@link StorageStrategyBase} for more details on file storage in MOVE.  In these routes,
 * `namespace` and `key` are used as described there.
 *
 * @type {Array<Hapi.ServerRoute>}
 */
const StorageController = [];

/**
 * Fetch the file at the given `namespace` and `key`.
 *
 * This was originally introduced to allow users to download ZIP archives of
 * reports, as generated by {@link JobController}.
 *
 * Note also that this endpoint does not currently set `Content-Disposition`.  Use `FileSaver`
 * to initiate client-side download of the response body.
 *
 * @memberof StorageController
 * @name getStorage
 * @type {Hapi.ServerRoute}
 */
StorageController.push({
  method: 'GET',
  path: '/storage/{namespace}/{key}',
  options: {
    description: 'Get the stored file at the given namespace / key',
    tags: ['api'],
    validate: {
      params: {
        namespace: Joi.string().required(),
        key: Joi.string().required(),
      },
    },
  },
  handler: async (request, h) => {
    const { namespace, key } = request.params;
    let fileExists;
    try {
      fileExists = await storageStrategy.has(namespace, key);
    } catch (err) {
      const { statusCode } = HttpStatus.BAD_REQUEST;
      return Boom.boomify(err, { statusCode, override: false });
    }
    if (!fileExists) {
      return Boom.notFound(`file not found in storage: ${namespace}/${key}`);
    }

    let mimeType = MimeTypes.lookup(key);
    if (mimeType === false) {
      mimeType = 'application/octet-stream';
    }

    const fileStream = storageStrategy.getStream(namespace, key);
    return h.response(fileStream)
      .type(mimeType);
  },
});

StorageController.push({
  method: 'GET',
  path: '/mvcr/{collisionYear}/{collisionMonth}/{collisionId}',
  options: {
    auth: {
      scope: [AuthScope.MVCR_READ.name],
    },
    description: 'Get the MVCR image corresponding to the collision specified by the params',
    tags: ['api'],
    validate: {
      params: {
        collisionYear: Joi.string().required(),
        collisionMonth: Joi.string().required(),
        collisionId: Joi.string().required(),
      },
    },
  },
  handler: async (request, h) => {
    const { collisionYear, collisionMonth, collisionId } = request.params;
    const sampleMvcrSubdirectory = 'mvcr-temp';
    const smapleMvcrFilename = 'sample_mvcr_redacted.pdf';

    let subdirectory = `mvcr/${collisionYear}/${collisionMonth}`;
    let mvcrFilename = `mvcr_${collisionYear}_${collisionMonth}_${collisionId}.pdf`;
    const fileExists = await storageStrategy.has(subdirectory, mvcrFilename, false);

    if (!fileExists) {
      const sampleFileExists = await storageStrategy.has(
        sampleMvcrSubdirectory, smapleMvcrFilename, false,
      );
      if (!sampleFileExists) {
        return Boom.notFound(`Both the requested MVCR ${mvcrFilename} and the sample MVCR ${smapleMvcrFilename} could not be fouund`);
      }
      subdirectory = sampleMvcrSubdirectory;
      mvcrFilename = smapleMvcrFilename;
    }

    const mimeType = 'application/pdf';
    const file = storageStrategy.getStream(subdirectory, mvcrFilename, false);
    if (mvcrFilename !== smapleMvcrFilename) {
      const { id: userId } = request.auth.credentials;
      const longCollisionId = `${collisionYear}:${collisionId}`;
      MvcrAccessEventsDAO.create(userId, longCollisionId, mvcrFilename);
    }
    return h.response(file).type(mimeType);
  },
});

export default StorageController;
